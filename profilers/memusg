#!/usr/bin/env bash
# memusg -- Measure memory usage of processes
# Usage: memusg --output-file=<file> COMMAND [ARGS]...
#
# Author: Jaeho Shin <netj@sparcs.org>
# Created: 2010-08-16
############################################################################
# Copyright 2010 Jaeho Shin.                                               #
#                                                                          #
# Licensed under the Apache License, Version 2.0 (the "License");          #
# you may not use this file except in compliance with the License.         #
# You may obtain a copy of the License at                                  #
#                                                                          #
#     http://www.apache.org/licenses/LICENSE-2.0                           #
#                                                                          #
# Unless required by applicable law or agreed to in writing, software      #
# distributed under the License is distributed on an "AS IS" BASIS,        #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #
# See the License for the specific language governing permissions and      #
# limitations under the License.                                           #
############################################################################
set -um

output_file="memusg.out"
remaining_args=()

echo $#

# Parse arguments to find --output-file and separate it from the command
while [[ $# -gt 0 ]]; do
    case $1 in
        --output-file)
            output_file="$2"
            shift 2
            ;;
        --output-file=*)
            output_file="${1#*=}"
            shift
            ;;
        *)
            # Add the remaining arguments (the command and its args) to an array
            remaining_args+=("$1")
            shift
            ;;
    esac
done

echo "OUTPUT FILE AFTER"
echo $output_file

# Ensure the output file is specified
if [[ -z "$output_file" ]]; then
    echo "Error: --output-file option is required." >&2
    exit 1
fi

# Make sure there is at least one argument remaining (the command to run)
if [[ ${#remaining_args[@]} -lt 1 ]]; then
    echo "Error: Command to run is required." >&2
    exit 1
fi

# Check input
[[ ${#remaining_args[@]} -gt 0 ]] || { sed -n '2,/^#$/ s/^# //p' <"$0"; exit 1; }

# TODO support more options: peak, footprint, sampling rate, etc.

pgid=$(ps -o pgid= $$)
# make sure we're in a separate process group
if [[ "$pgid" == "$(ps -o pgid= $(ps -o ppid= $$))" ]]; then
    cmd=
    set -- "${remaining_args[@]}"
    for a; do cmd+="'${a//"'"/"'\\''"}' "; done
    echo $cmd
    exec bash -i -c "$cmd"
fi

# detect operating system and prepare measurement
case $(uname) in
    Darwin|*BSD) sizes() { /bin/ps -o rss= -g $1; } ;;
    Linux) sizes() { /bin/ps -o rss= -$1; } ;;
    *) echo "$(uname): unsupported operating system" >&2; exit 2 ;;
esac

# monitor the memory usage in the background.
(
peak=0
while sizes=$(sizes $pgid)
do
    set -- $sizes
    sample=$((${@/#/+}))
    let peak="sample > peak ? sample : peak"
    sleep 0.1
done
echo "$peak" > "$output_file"
) &
monpid=$!

# run the given command
exec "${remaining_args[@]}"
